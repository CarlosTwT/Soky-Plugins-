const rmbg = await import('../../storage/script/removebg.js');

export default {
  name: 'removebg',
  tags: 'tools',
  command: ['removebg'],
  description: 'Quitar fondo en fotos',
  example: '',
  limit: true,
  run: async(m, { sock, args }) => {
    let q = m.quoted ? m.quoted : m
    let mime = (q.msg || q).mimetype || ''
    if (!mime) return m.reply('Umhhh... y la foto??')
    m.reply(global.status.wait)
    let dor = await rmbg.removeBg(await q.download());
    let buffer = Buffer.from(dor, 'base64');
    await sock.sendMessage(m.chat, { image: buffer, caption: 'Se eliminó con éxito el fondo de la foto.' }, { quoted: m })
  }
}


//
/*
 * *[Plugins Text To Pdf]*
 * https://whatsapp.com/channel/0029VaGgcSa3bbV4dMm9Fe3B
*/

import PDFDocument from 'pdfkit';
import {
    Writable
} from 'stream';

export default {
  name: 'textpdf',
  tags: 'tools',
  command: ['topdf'],
  description: 'crear pdf mediante texto',
  example: '',
  run: async(m, { sock, args }) => {
    let query = `escribir un texto\nEx. *.topdf* hello world\n<comando> <text>`
    let text
    if (args.length >= 1) {
        text = args.slice(0).join(" ")
    } else if (m.quoted && m.quoted.text) {
        text = m.quoted.text
    } else throw query
    
    await m.reply(wait)
    try {
        let pdf = await textToPDFBuffer(text)
            .then(buffer => {
                // Use the resulting buffer as needed
                return (buffer);
            })
        await conn.sendMessage(m.chat, {
            document: pdf,
            mimetype: "application/pdf",
            fileName: `For ${m.name}.pdf`
        }, {
            quoted: m
        })
        } catch (e) {
        await m.reply(eror)
        }
}

async function textToPDFBuffer(text) {
    return new Promise((resolve, reject) => {
        const buffers = [];
        const streamBuffer = new Writable({
            write(chunk, encoding, next) {
                buffers.push(chunk);
                next();
            },
        });

        const doc = new PDFDocument();

        doc.pipe(streamBuffer);
        doc.text(text);
        doc.end();

        streamBuffer.on('finish', () => {
            const pdfBuffer = Buffer.concat(buffers);
            resolve(pdfBuffer);
        });

        streamBuffer.on('error', reject);
    });
}